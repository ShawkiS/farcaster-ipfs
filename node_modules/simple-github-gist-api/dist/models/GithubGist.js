"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const axios_1 = require("axios");
const auth_config_1 = require("../util/auth-config");
const token_validity_1 = require("../util/token-validity");
const is_string_empty_1 = require("../util/is-string-empty");
const formatted_gist_identifier_1 = require("../util/formatted-gist-identifier");
const constants_1 = require("../constants");
const GistFile_1 = require("./GistFile");
class GithubGist {
    constructor(options) {
        var _a, _b;
        this.gistId = '';
        this.gistOwner = '';
        this.gistFiles = [];
        /**
         * Syncs the gistInstance with Github server. Should be done only once,
         * right after instantiation of this class.
         */
        this.touch = () => __awaiter(this, void 0, void 0, function* () {
            // Throws error if the token is not valid.
            yield (0, token_validity_1.default)(this.personalAccessToken);
            // Fetch and set the gist ID
            yield this.fetchGist();
            // If gist ID is not set, it means the Gist doesn't exist. Create a new gist
            if ((0, is_string_empty_1.default)(this.gistId)) {
                yield this.createGist();
            }
        });
        /**
         * Creates a file in the gist. If file already exists, it over-writes the
         * content of the file.
         *   Returns, true, if file was created.
         *   Returns, false, if existing file was updated.
         *
         * @param name
         * @param content
         */
        this.createFile = (name, content) => {
            const existingFile = this.gistFiles.find((file) => file.name === name);
            if (existingFile) {
                existingFile.overwrite(content);
                return false;
            }
            const file = this.constructGistFile(name, content);
            this.gistFiles.push(file);
            return true;
        };
        /**
         * Get a particular file instance. Returns null if file not found.
         *
         * @param name
         */
        this.getFile = (name) => {
            const file = this.gistFiles.find((file) => file.name === name);
            if (file)
                return file;
            // File not found
            return null;
        };
        /**
         * Get all file instances
         */
        this.getFiles = () => {
            return [...this.gistFiles];
        };
        /**
         * Returns the names of all the files in the gist.
         */
        this.getFileNames = () => {
            return this.gistFiles.map(file => file.name);
        };
        /**
         * Saves all the files in the gist, only if they have updates
         */
        this.save = () => __awaiter(this, void 0, void 0, function* () {
            const files = {};
            for (const file of this.gistFiles) {
                if (file.hasUpdates === false)
                    continue;
                files[file.name] = {
                    content: file.content,
                };
            }
            // No files need updates
            if (Object.keys(files).length === 0)
                return;
            const url = `${constants_1.default.githubGists}/${this.gistId}`;
            const body = { public: this.isPublic, files };
            yield axios_1.default.post(url, body, (0, auth_config_1.default)({ personalAccessToken: this.personalAccessToken }));
            // Mark the hasUpdates flag in all the files as false.
            this.gistFiles.forEach((file) => {
                file.hasUpdates = false;
            });
        });
        /**
         * [Private Member] Fetches the gist information.
         */
        this.fetchGist = () => __awaiter(this, void 0, void 0, function* () {
            // Gets all the gists basic information
            const result = yield axios_1.default.get(constants_1.default.githubGists, (0, auth_config_1.default)({ personalAccessToken: this.personalAccessToken }));
            const gists = result.data;
            for (const gist of gists) {
                const fileNames = Object.keys(gist.files);
                // If the formattedAppIdentifier file exists in gist, this is out gist.
                if (fileNames.includes(this.formattedAppIdentifier)) {
                    yield this.initialize(gist);
                    break;
                }
            }
        });
        /**
         * [Private Member] Creates the gist
         */
        this.createGist = () => __awaiter(this, void 0, void 0, function* () {
            const { identifier: { content }, githubGists } = constants_1.default;
            const rootFileContent = content.replace('<APP-NAME>', this.appIdentifier);
            const payload = {
                public: this.isPublic,
                files: {
                    [this.formattedAppIdentifier]: {
                        content: rootFileContent
                    }
                }
            };
            // Create gist API call
            const result = yield axios_1.default.post(githubGists, payload, (0, auth_config_1.default)({ personalAccessToken: this.personalAccessToken }));
            const gist = result.data;
            // Initialize the current instance with the gist meta-information
            yield this.initialize(gist);
        });
        /**
         * [Private Member] Initializes the instance with the information from server.
         * @param gist
         * @private
         */
        this.initialize = (gist) => __awaiter(this, void 0, void 0, function* () {
            // Set gist meta
            this.gistId = gist.id;
            this.gistOwner = gist.owner.login;
            const fetchFileContent = [];
            // Initialize all the files
            this.gistFiles = [];
            for (const fileName of Object.keys(gist.files)) {
                const file = this.constructGistFile(fileName, '');
                fetchFileContent.push(file.fetchLatest());
                this.gistFiles.push(file);
            }
            // Fetching content of all the files.
            yield Promise.all(fetchFileContent);
        });
        /**
         * [Private Member] This constructs the GistFile instance
         * @param fileName
         * @param content
         */
        this.constructGistFile = (fileName, content) => {
            return new GistFile_1.default({
                fileName,
                fileContent: content,
                gistId: this.gistId,
                gistOwner: this.gistOwner,
                cors: {
                    addPrefix: this.addCorsPrefix,
                    customPrefix: this.customCorsPrefix,
                },
                personalAccessToken: this.personalAccessToken,
                isPublic: this.isPublic,
            });
        };
        this.personalAccessToken = options.personalAccessToken;
        this.appIdentifier = options.appIdentifier;
        this.formattedAppIdentifier = (0, formatted_gist_identifier_1.default)(options.appIdentifier);
        this.isPublic = Boolean(options.isPublic);
        this.addCorsPrefix = Boolean((_a = options.cors) === null || _a === void 0 ? void 0 : _a.addPrefix);
        this.customCorsPrefix = (_b = options.cors) === null || _b === void 0 ? void 0 : _b.customPrefix;
    }
    // Getters
    get id() { return this.gistId; }
    ;
    get ownerUsername() { return this.gistOwner; }
    ;
}
exports.default = GithubGist;
